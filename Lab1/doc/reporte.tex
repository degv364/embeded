\input{../../general/doc/preamble.tex}

\title{Universidad de Costa Rica\\{\small Facultad de Ingeniería\\Escuela de Ingeniería Eléctrica\\
    Laboratorio Sistemas incrustados\\II ciclo 2017\\\vspace*{0.55in} Reporte de Laboratorio}\\ Práctica I \vspace*{1.1in}}
\date{20 de Setiembre de 2017}

\begin{document}

\input{../../general/doc/portada.tex}


\newpage

\section{Problema a Resolver}
Se debe hacer una prueba de concepto para una luz de noche. Este sistema debe ser capaz de sensar la
luz ambiental y el ruido, para determinar si es necesario encender o no las luces. El objetivo es
qeu se pueda utilizar en casas con niños pequeños para cuando se despiertan en medio de la noche. 


En la tabla \ref{tab:reg_table} se muestran los requerimientos solicitados, y si se lograron para la
fecha de entrega.

\begin{table}[]
\centering
\caption{Tabla de requerimientos}
\label{tab:reg_table}
\begin{tabular}{|c|c|c|p{7cm}|}
  \hline
  Completado & Código & Requerimiento & Descripción\\
  \hline
  Sí & SRS-001 & Número de luces a controlar &El producto debe ser capaz de controlar una, dos, o
                                               tres lámparas LED\\
  \hline
  Sí & SRS-002 & Confirmación de funcionamiento & Una vez energizado el sistema la lámpara debe
                                                  parpadear 3 veces, luego pasa al estado inicial\\
  \hline
  Sí & SRS-003 & Estado inicial de iluminación & El producto debe ser capaz de determinar el nivel
                                                 inicial de luz, para saber si el estado inicial de
                                                 la lámpara es encendido o apagado \\
  \hline
  Sí & SRS-004& Tiempo de lámpara encendida & La lámpara debe cumplir con el tiempo mínimo de
                                            encendido, luego del cual se apaga, si no encuentra la
                                              condición de encendido \\
  \hline
  Sí & SRS-005& Tiempo de lámpara apagada & La lámpara se debe mantener apagada indefinidamente,
                                            hasta que se encuentre la condición de encendido\\
  \hline
  Sí & SRS-006& Condición de encendido & La lámpara se debe encender si el nivel le iluminación se
                                         encuentra por debajo del umbral día-noche, y el nivel de
                                         sonido es 10 por ciento mayor al promedio de los últimos 5
                                         segundos por un segundo\\
  \hline
  Sí & SRS-007& Botón de Control&  El usuario debe disponer de un botón de control, que alterna el
                                  estado de la lámpara. Al encenderla debe respetar un tiempo mínimo
                                  de encendido\\
  \hline
  
\end{tabular}
\end{table}


\section{Contexto de Mercado}

Hay varias propuestas en el mercado de productos parecidos. Entre ellos destaca \textit{Sensky
  Skl001}, que es una lámpara que se acciona por luz y por movimiento. Funciona parecido al producto
propuesto para este laboratorio, pero no tiene sensor de audio. Tiene un costo aproximado de 14
dólares. En general los clientes está complacidos con el producto pero una queja común es que no se
apaga por completo, sino que siempre tiene una leve luz activada durante la noche, y que por tanto
no lo recomiendan para cuartos, sino que es mejor para pasillos.
% https://www.amazon.com/Sensky-Activated-Bedroom-Staircase-Hallway/dp/B0132IB68G/ref=sr_1_5/132-4000312-3358733?s=lamps-light&ie=UTF8&qid=1505612984&sr=1-5&refinements=p_n_feature_ten_browse-bin%3A5587102011

Otro que destaca es \textit{ZAZU}, se trata de una lámpara en forma de búho con un aro luminoso alrededor. El
búho y el aro tienen 3 intensidades de luz ajustables de forma independiente, y además es activado
por sonido. Tiene un costo aproximado de 40 dólares. Varios de los comentarios positivos se refieren
a que existen dos fuentes de luz configurables por separado, en muchos casos utilizan el aro para
leer un libro antes de dormir, y la luz del búho para que el niño se duerma. La mayor parte de las
quejas se refieren a que la activación por sonido no funciona bien, ya que no se enciende aún cuando
los niños lloran.
% https://www.amazon.com/Zazu-Kids-Voice-Activated-Nightlight/dp/B00WSB43XY/ref=sr_1_1?s=lamps-light&ie=UTF8&qid=1505613867&sr=1-1&keywords=voice+activated

Otro producto que destaca es \textit{Zitrades Baby Night Rainbow}. Se trata de un arcoiris luminoso que se
activa por luz y por sonido. No es tan configurable como ZAZU, pero cuesta menos de la mitad,
aproximadamente 17 dólares. Tiene varias reseñas positivas, que en su mayoría se refieren a lo
tierno del diseño y a que a los niños les gusta mucho. Los comentarios negativos se refieren a un
comportamiento errático de las luces, en muchos casos se encienden sin una razón aparente y aveces
provoca detellos que despiertan alos niños. En un caso, los destellos llegaron a asustar a una delas
hijas de los clientes, pero no lo devolvieron porque tiene un diseño muy tierno.
% https://www.amazon.com/Zitrades-Rainbow-Toddler-Nightlight-Sensor/dp/B0111AA67Y/ref=sr_1_9?s=lamps-light&ie=UTF8&qid=1505614831&sr=1-9&keywords=voice+activated

Se debe tomar en cuenta que este es un producto para niños y por tanto se le da mucha importancia a
que tenga un diseño adorable. En muchos casos aunque el producto no cumplía con las expectativas de
los padres, los niños se sentían muy contentos. Esto es algo que no se toma en cuenta para este
laboratorio, pero es importante contemplarlo para poder sacar el producto a la venta. Por otra parte
la mayor parte de las quejas son por el funcionamiento del producto, que sí está vinculado con el
desarrollo de este laboratorio. De los resultados experimentales realizados, no se han observado
comportamientos erráticos en las luces ni que el sistema falle en detectar el sonido; como sucede con
los productos competidores.

Otro aspecto importante a tomar en cuenta es que ninguno de los productos se mantenía encendido por
tanto tiempo como se solicita en la descripción de este laboratorio. El que tarda más tiempo
encendido dura 7 minutos. Por lo que se deben reevaluar los 30 minutos propuestos antes de sacar el
producto al mercado.  

\section{Solución Propuesta}

\section{Configuración de periféricos}

\subsection{Timer}
Para el conteo del tiempo se utiliza el módulo Timer32\_1, el cual se configura para generar una
determinada cantidad de interrupciones por segundo (definido en TIME\_INTERRUPTS\_PER\_SECOND). Para
esto se utiliza el modo periódico (TIMER32\_PERIODIC\_MODE) para poder determinar el valor máximo
desde el cual se genera la cuenta regresiva hacia 0, y así establecer la cantidad de interrupciones
deseada en función de dicho valor máximo y la frecuencia del timer, la cual se obtiene de preescalar
por 16 (TIMER32\_PRESCALER\_16) el MCLK (que se encuentra operando a 3 MHz). También, se configura
el Timer en modo continuo, de manera que una vez el conteo llega a 0 el mismo se vuelve a reiniciar
de manera automática. A parte de esto se deben activar las interrupciones, las cuales se generan
cuando el valor de conteo llega a 0.

En este caso, las interrupciones se utilizan para incrementar un contador por software que lleva una
medición del tiempo transcurrido, en donde la cantidad de interrupciones por segundo determina la
precisión de la escala de tiempo.


\subsection{Sensor de luz con I2C}
Para enviar la configuración del sensor de luz al OPT3001 se utiliza el protocolo I2C, en donde la
funcionalidad requerida se establece mediante la escritura del registro de 16 bits llamado
\texttt{Configuration Register (01h)}. Para la solución implementada se aplicó la configuración de
rango de escala completa automático, de forma que el sensor se adapta al rango de los valores
medidos de manera dinámica para dar una mejor precisión. Además, se establece que el tiempo de
conversión sea de 100 ms, tal que se pudiera tener un nuevo resultado tan rápido como fuera posible
para el sensor. Se utiliza también el modo de conversión continua, para que el sensor constantemente
se encuentre capturando nuevas mediciones. Todo esto implica escribir en dicho registro el valor
\texttt{0xC410}.

Por otra parte, a pesar de que el sensor de luz (OPT3001) permite generar interrupciones para
detectar si los valores de medición se encuentran en un rango válido, estas no se emplean en el diseño.

Con respecto al protocolo I2C, fue necesario configurar los pines P6.5 como I2C\_SCL, y P6.4 como
I2C\_SDA, los cuales se encuentran conectados al sensor de luz. Además, se utiliza MCLK como reloj
para la interfaz I2C y se configura una tasa de datos de 400 Kbps.  

\subsection{Micrófono con ADC}
Con respecto a la configuración del módulo ADC, en primer lugar se configura el MCLK como el reloj
para el mismo, el cual opera a 3 MHz. Esto permite que el proceso de conversión analógico-digital se
pueda llevar a cabo con suficiente rapidez. Por otra parte, se utiliza el modo de una sola muestra
(\textit{Single Sample Mode}) tal que los resultados de la conversión siempre se encuentren en el
registro \texttt{MEM0}. Para obtener las mediciones del micrófono se configura el pin al cual este
se encuentra conectado (P4.3) con la función alternativa terciaria, de manera que este se pueda
utilizar como una entrada para el ADC, la cual corresponde a la entrada A10. Además, se establece el
modo de repetición (\textit{Repeat Mode}), tal que no sea necesario activar la bandera de
habilitación de conversión (\texttt{ADC14ENC}) para volver a iniciar otra conversión, si no que esta
se envía una sola vez y el módulo permite procesar nuevas muestras de manera automática, al enviar la
señal de muestreo y conversión (\texttt{SAMPCON}).

Con respecto a la señal de muestreo, esta se establece mediante el TimerA0, de forma que el proceso
de muestreo ocurre de manera automática por hardware en lugar de requerir una activación por
software mediante la bandera \texttt{ADC14SC}. En este sentido, se configura el TimerA0 con el reloj
\texttt{ACLK}, el cual es alimentado con la fuente \texttt{REFO}, de forma que se opera a una
frecuencia de 32 KHz y en donde no se utiliza preescalado. Este timer se configura para operar en
\textit{Up Mode}, en el cual se cuenta hacia arriba y se puede configurar el valor máximo de conteo
mediante el registro \texttt{CCR0}, después del cual se reinicia el conteo a 0. Se deshabilitan las
interrupciones de este módulo que se activan al contar hacia (CCIFG) y desde (TAIFG) \texttt{CCR0},
ya que estas no son requeridas para la interacción con el ADC. 

La señal de muestreo se genera a partir de una salida del TimerA0 (\texttt{OUT1}), la cual se puede
considerar de tipo PWM y se establece según el valor del registro \texttt{CCR1} (Capture Compare
Register 1) y el modo \textit{Set/Reset}. Este registro se configura tal que tiene el mismo valor
que el valor máximo de conteo (\texttt{CCR0}), de manera que la señal se mantiene en bajo hasta
llegar exactamente al último valor de conteo, y se mantiene en alto solamente durante dicho número
(un ciclo del TimerA0, ACLK), volviendo a estar en bajo en el siguiente ciclo, en el cual se regresa
al valor de conteo de 0. Esto se hace así porque permite establecer la frecuencia de muestreo
mediante el valor máximo de conteo, y porque esta señal debe estar en alto durante un tiempo
reducido (debe ser menor a $420~\mu s$, en este caso es $1/ACLK \approx 30.5~\mu s$ ), en el cual se
lleva a cabo el muestreo de la entrada analógica.


\subsection{GPIOs}
Los GPIOs (General Purpose Input Output) se emplean tanto para las salidas de los LEDs como para la
entrada del botón. En el caso de los LEDs, se configuran los pines correspondientes como salidas, y
se controlan según la lógica del programa. 

Para el funcionamiento del botón, se configura el pin correspondiente como entrada y se habilita la
interrupción en la transición de alto a bajo en el valor de entrada. De esta forma, cuando se
presiona el botón (normalmente en alto) se genera un pulso negativo que activa la interrupción, lo
cual permite detectar cuando el usuario utiliza el control manual. 


%--------------------------------
\section{Implementación}
%-------------------------------

Para mejorar el desarrollo de la solución de este laboratorio, se tomó la decisión de dividir todo
el código en la parte que depende del hardware, y la que no depende del hardware. De esta manera se
pueden tener avances y pruebas sin necesidad de tener la tarjeta de desarrollo (dos integrantes con
una sola tarjeta). El código que depende del hardware se probó en la tarjeta directamente, por otra
parte el código que no es dependiente del hardware se probó utilizando el ``unit testing'' que
ofrece \textit{google-test}.

Otro criterio importante de diseño es que se modularizó el código, de manera que cada sensor se
maneja con su propia clase, y las partes que son independientes del hardware se separaron
también. Esto tiene la ventaja que permite tener código más entendible, y hace más fácil hacer
modificaciones del funcionamiento del proyecto. De hecho durante el desarrollo del proyecto se
hicieron varios cambios en el funcionamiento de ciertos módulos, y esto no afectó al resto de
módulos. Por ejemplo se cambió la manera en que se calcula si el segundo actual está sobre el
promedio establecido para encender la luz. Solo se hicieron cambios en uno de los módulos, y el
resto del proyecto no sufrió modificaciones.

Se tiene un loop de control principal, que al inicio se encarga de inicializar el hardware y los
periféricos y luego se encarga de iterar periódicamente y definir su comportamiento dependiendo de
las lecturas de los sensores. Es importante destacar que las lecturas de los sensores no se hace
dentro de este loop principal, sino que se manejan con sus propias interrupciones, por lo que fue
necesario crear el \textbf{struct de sensores} que se explica más adelante. 


\subsection{Código dependiente del hardware (HD)}

\subsubsection{Lámparas}
Para facilitar el desarrollo relacionado con GPIO, se crea una clase con el mismo nombre. Es una
capa de abstracción sobre driverlib, para ofrecerle un API más generalizado a la parte que es
independiente del hardware. OutputGPIO es una clase qeu hereda de GPIO y se refiere exclusivamente a
pines de salida.

En el constructor de la clase  se selecciona el puerto, el pin y el modo (o función). EN caso que
nos e especifique, se utiliza salida digital. Además se implementan 3 métodos: set, reset y
toggle. Set se encarga de poner el pin en High, reset de ponerlo en Low, y toggle de conmutar al
estado opuesto al actual.

Se creó una clase extra: LampHandler. Esta clase se encarga de abstraer el problema de la cantidad
de lámparas habilitadas, y proporcionarle un API a la máquina de estados que esconde esta
complejidad. A la hora de inicializar la clase se decide la cantidad de lámparas habilitadas, pero
cabe destacar que se diseñó para que se pueda cambiar esta cantidad en cualquier momento durante la
ejecución.

Por dentro se instancian tres objetos de tipo OutputGPIO, uno para cada lámpara. y se controlan con
los métodos (de LampHandler) lamps\_on, lamps\_off, lamps\_toggle, y lamps\_alive\_sequence. Todos los
métodos son evidentes a partir de lo expuesto anteriormente, excepto por el último. Este se encarga
de encender y apagar la lámparas para mostrar la secuencia de inicialización. 

\subsubsection{Botón de Control}
% FIXME: hablar de InputGPIO
% FIXME: explicar interrupcion
% FIXME: talvez hablar del problema de detección doble?

\subsubsection{Sensor de Luz}
% FIXME: Configuración e i2c
\subsubsection{Micrófono}
% FIXME: configuración, ADC, Timer




\subsection{Código independiente del hardware (HI)}

\begin{figure}
\centering
\scalebox{.5}{\input{data_flow.tex}}
\caption{Diagrama de Flujo de datos}
\label{fig:data_flow}
\end{figure}


\subsubsection{Struct de sensores}
La toma de datos de los sensores es asincrónica respecto al ciclo de control principal. Entonces se
utiliza una estructura para definir la interfaz de comunicación entre ambas partes. Este es el
struct de sensores, Como se muestra en la figura \ref{fig:data_flow}. En este se guarda la
información relevante que necesita la máquina de estados para definir el comportamiento del
sistema. Se guardan 4 valores, el primero es el valor de tiempo. En este se guarda la cantidad de
tiempo que ha pasado, ya que algunas transiciones de estado están definidas por \textit{timeouts},
como por ejemplo cuando la lámpara se enciende cuando la habitación está oscura y se detecta ruido,
el retorno al modo automático está asociado a un \textit{timeout}.

El segundo guarda un booleano que indica si el botón de control ha sido presionado. Entonces cuando
se atiende la interrupción de presionar el botón, se guarda el dato en el struct de sensores, y
en luego la máquina de estados se encarga de retornar el valor a su estado inicial.

La tercer entrada del struct de sensores se refiere al sensor de luz. Cuando se atiende la
interrupción del sensor de luz, se compara con el \textit{threshold} establecido experimentalmente y
se guarda en el struct un booleano que indica si la lectura actual superó o no dicho
threshold. También estaba la opción de tener una atención de interrupción más simple y solo guardar
el dato del sensor en el struct de sensores y que luego el loop de control principal se encargara de
hacer la comparación. Sin embargo se tomó la decisión que el loop principal fuera independiente del
hardware y por tanto debería funcionar independientemente del threshold de luz que se utilice (que
depende del sensor). Entonces era mejor que el código HD se encargara de la comparación.

La última entrada del struct de sensores es para el micrófono, y se guarda un booleano que indica si
el último segundo cumple la condición de estar sobre el promedio establecido por los cinco segundos
anteriores. Se decide guardar solo el booleano y no los datos por la misma razón expuesta para el
caso del sensor de luz.

\subsubsection{Fifo de manejo del micrófono}

Una de las operaciones más complejas de este primer laboratorio era identificar si se cumplían las
condiciones para encender la lámpara. Para el caso del sensor de luz es muy sencillo porque no se
debe tomar en cuenta la historia, sino que solo importan datos inmediatos. Por otra parte para el
caso del micrófono se debe tomar en cuenta los últimos 5 segundos, y compararlo con el último
segundo escuchado.

Para mantener el criterio de diseño de modularizar lo más posible, se decide crear una clase que se
encarga de manejar este problema. A lo interno tiene un fifo donde se guardan los datos del
micrófono y tiene métodos para agregar nuevas muestras y para identificar si se cumple o no la
condición de sonido para encender la lámpara.

Lo primero que se debe considerar es que se tienen dos fifos. El primero guarda los datos
recolectados por los últimos 6 segundos. Esto se hace porque según las especificaciones se debe
comparar el último segundo con el promedio de los últimos 5 segundos. Si solo se guardan 5 segundos
entonces el promedio del último segundo estaría contemplado dentro del promedio de los cinco
segundos, entonces para mejorar la correctitud del sistema se tomó la decisión de guardar un segundo
más, de manera que los datos del último segundo no afecten el promedio contra el que se deben
comparar.

Para optimizar el proceso de obtener el promedio de los cinco segundos, este se
actualiza cada vez que se agrega un nuevo dato. Se sabe el dato entrante (a la parte del fifo que
define los cinco segundos, este no es el dato recién agregado pues pertenece al último segundo, y
no se debe tomar en cuenta para el promedio), y el dato saliente, por lo que se puede utilizar
(\ref{eq:promedio}) para calcular el promedio. Donde $N$ es la cantidad de muestras en los cinco
segundos (depende de la frecuencia de muestreo), $s$ se refiere a una muestra o \textit{sample}, y
$P$ se refiere al promedio.

\begin{equation}
  P_{new} = P_{old}-\frac{s_{out}}{N}+\frac{s_{in}}{N}
\end{equation}

El segundo fifo se utiliza para identificar si se cumple la condición necesaria de intensidad sonora
para encender la lámpara, en este solo se contemplan las muestras del último segundo.  Cada vez que
entra una muestra nueva, se compara con el promedio actual de los cinco segundos, y en caso de ser
mayor al umbral definido, se guarda como un acierto. Cuando todos los valores en el fifo son
aciertos se sabe que se cumple la condición. No se hace una simple comparación de promedios porque
experimentalmente se descubrió que era muy fácil activar la lámpara, lo que aumentaba los falsos
positivos. Luego de agregar este fifo extra se observó un mejor comportamiento.

\section{Máquina de estados}

La máquina de estados es el módulo que toma los valores del struct de sensores y con ellos decide el
estado del sistema. Además hace las llamadas a las funciones de los actuadores, que en este caso son
las lámparas. 

Se definen los siguientes estados:

\begin{itemize}
\item \textbf{None}: Este es el estado con el que se inicializa el objeto. 
\item \textbf{Init}: Indica que el sistema se encuentra en el estado de inicialización, que en el
  caso particular de este proyecto, ocurre mientras se configuran los periféricos.
\item \textbf{Alive\_sequence}: Indica que el sistema se encuentra realizando la secuencia de
  inicialización para indicar su correcto funcionamiento. Hasta que se complete la secuencia, se
  pasa al siguiente estado. 
\item \textbf{ON}: La lámpara se encuentra encendida.
\item \textbf{OFF}: La lámpara se encuentra apagada.
\item \textbf{Manual\_control}: Este es el estado al que entra el sistema cuando se presiona el
  botón de control y la luz estaba apagada, entonces se enciende por un tiempo determinado. Es
  distinto a \textbf{ON} porque no se hacen lecturas de luz o sonido para apagar la lámpara antes
  qeu se complete el tiempo.
\item \textbf{Fail}: Este es el estado para manejo de errores. En este proyecto no hay rutinas que
  puedan generar errores. Lo peor es que haya un error con los sensores, pero en ese caso simplemente
  no se hacen actualizaciones al struct de sensores. 
\item \textbf{Deinit}: Deinicialización del sistema. Como se espera un funcionamiento continuo este
  estado no se utiliza, pero sería utilizado en caso de fallas críticas. 
\end{itemize}

En la figura \ref{fig:state_machine} se muestra el diagrama de flujo de la máquina de estados. 

\begin{figure}
\centering
\scalebox{.4}{\input{state_machine.tex}}
\caption{Diagrama de la Máquina de Estados}
\label{fig:state_machine}
\end{figure}



\newpage
%-------------------------------
\section{Problemas encontrados}
%-------------------------------



\newpage
%-------------------------------
\section{Posibles Mejoras}
%-------------------------------


\newpage
%----------------------
% Bibliografía
%----------------------


%\bibliographystyle{apacite}
%\bibliography{../general/biblografia.bib}
%---------------------------------------------------------------------------------------------------------------
\end{document}